# -*- coding: UTF-8 -*-
from django.core.management.base import BaseCommand, CommandError
from questions.models import Question, Tag, Profile, Answer
from datetime import datetime
from django.utils import timezone
import random

class Command(BaseCommand):
    def handle(self, *args, **options):
        answers = ['Руководствуйтесь смыслом, и только им. Строение ваших классов должно отображать не техническую возможность сделать так или иначе (иногда экземплярные методы можно объявить статическими), а отношения между объектами в доменной области. Это и правда база всего ООП (а где ж ещё следовать ООП, если не в Джаве?). \n Я не могу привести цитату из умной книги по этому поводу. Но сама идея делать сигнатуру метода зависимой не от его смысла, а от подробностей его конкретной имплементации кажется мне грубым хаком. Даже если это внутренний, приватный метод. Если в публичных методах, предназначенных другим, мы пишем правильно, то почему в методах, предназначенных для себя, писать неправильно?',
                   'Во-первых, для начала хорошо бы определиться, а нужен ли этому классу данный метод? Скажем, есть у нас класс машины и метод по переводу километров в мили. \n public class Car { \n	private static double convertToMiles(double km){ \n	return km*0.621371192; \n\t}\n} \n Очевидно, что этот метод вообще не нужен классу и его хорошо бы вынести в отдельный final Utils подобный класс, так как может быть использован много где.',
                   'Для более глубокого понимания добавлю исторический контекст вообще о статических методах. Некоторые исследователи вопроса вообще считают все подобные методы злом в ООП.\n Когда тема трудна для понимания, то один из лучших способов - обратиться к истории. Java произошла от Smalltalk. Это знают все кто хоть один день потратил на его изучение. В языке Smalltalk (с 1971 года) уже были статические методы - правда они там идут под названием "методы класса". Откуда же они появились там? Smalltalk имеет еще одного предка - Simula (с 1965 года). Оказывается и в Simula были такие методы - только там они идут под названием "свободный блок". Но в свою очередь кто "протащил" с язык Симула эти "свободные блоки"? А предок Симулы - Алгол. Потому что Симула изначально надмножество Алгола 60. Так что вот откуда ноги растут:',
                   'Это же рекомендации для разработчиков фреймворков. Очевидно, что разработчики фреймворков будут выпускать новые версии своих фреймворков. Также понятно, что одной из важнейших задач для них - сохранение обратной совместимости, по мере возможностей. А значит, что клиентов, что используют их код, следует максимально ограничить. То есть, это мы (ну или только я такой рукожоп) привыкли писать классы наследуемыми - но если мы пишем фреймворк, то нужна достаточно веская причина сделать класс наследуемым. Также нужна веская причина сделать метод виртуальным. Но вот ты сделал публичный метод виртуальным, и теперь клиенты могут наследоваться, перегрузить метод и запускать сами написанный ими же код, используя наш фреймвок - и мы уже не можем это контролировать. Я к тому, что делая публичный метод виртуальным, мы даем право клиенту решать, что будет делать наш АПИ и мы уже никак не можем ничего изменить, не сломав обратную совместимость. Однако, сделав защищенный метод виртуальным, мы не гарантируем клиенту, что этот метод не перестанет использоваться в будущем, если наш публичный АПИ будет изменен. Таким образом клиенты, что перегрузили защищенный метод, сохраняют обратную совместимость, даже если логика публичных методов была изменена. ',
                   'Публичные методы суть контракт класса. Если публичный метод объявлен как виртуальный, это означает, что подкласс легко может переопределить его таким образом, что контракт будет нарушаться. \n В случае с защищенными методами сломать контракт не так легко (а иногда невозможно), поскольку основная логика жестко зашита в невиртуальном публичном методе, в котором есть точки расширения -- те самые защищенные виртуальные методы.\n Иногда такой прием можно использовать и для защиты от забывчивых программистов, чтобы, переопределяя метод, они "не забыли" вызвать базовую логику. Что-то типа такого. \n Поэтому да, "do prefer". Но именно prefer.',
                   'Я довольно часто применяю такой подход, хотя, честно говоря, раньше мне эта рекомендация на глаза не попадалась. Причины довольно простые, в начале разработки некоторой иерархии классов не всегда понятно (скорее всегда непонятно) какой код публичного метода будет общим, а какой потребует переопределения в наследниках. Поэтому, в качестве отправной точки, публичный метод просто вызывает защищенный виртуальный метод. В дальнейшем, общий код из защищенного метода переезжает в публичный метод, а специфический остается в защищенном, если по итогам весь код остался в защищенном методе, а в публичном остался только вызов этого метода, то переносим весь код в публичный метод и делаем его виртуальным.\n Разумеется можно идти и обратным путем - последовательно выносить специфику в отдельный метод, но это обычно требует от меня больше внимания и ручной работы. Каких-то реальных проблем, как, например, в случае с публичными полями вместо свойств или константами вместо свойств только для чтения, при использовании виртуальных публичных методов я ни разу не наблюдал.',
                   'Я очень уважаю Рихтера за глубину изложения и технические подробности, но есть один момент в его книгах, который меня очень беспокоит. Это его советы по поводу того, что хорошо, а что плохо в вопросах стиля или проектирования. Вот этот совет из их числа.\n \t Актуально ли это сейчас?\nЕсть ряд советов, особенно в вопросах эффективности, на которые очень сложно ответить правильно, ибо "правильность" сильно зависит от вашего приложения. Например, человек, который работал над достаточно высоконагруженным приложением может дать такой совет "Никогда не используйте LINQ". Совет вполне разумен, если речь идет о критических участках высоконагруженного приложения, но очень плох в общем случае, ибо применим лишь для жалких полупроцента приложений. \n Совет из серии "выделяйте конструкторы и не используйте field-like инициализаторы" звучит еще смешнее, поскольку применим еще к меньшему числу use case-ов.',
                   'В Oracle PL\SQL при вызовах процедур и функций можно явно указать какому параметру какое значение передается.\n<процедура>(<имя_парметра_2> =>\n<значение_параметра_2>,\n\t<имя_парметра_1> => <значение_параметра_1>);\nЧто это дает?\nЕсли у нас есть несколько перегруженных функций, с разными типами параметров, то иногда это единственный способ вызвать нужную нам функцию.\nМожно указывать параметры в произвольном порядке\nУлучшает читаемость кода',
                   'Существуют три способа вызова подпрограмм:\nPositional notation - актуальные параметры задаются в том же порядке, в котором они объявлены при декларации.\nNamed notation - актуальные параметры задаются в любом порядке используя синтакс:\nformal => actual\nMixed notation - сначала задаются параметры используя positional notation, затем используется named notation для остальных параметров.\nОтличие в регистре в примере вопроса не играет никакой роли, до символа => формальный параметр (formal), а после актуальный (actual). Их имена могут полностью совпадать.\nNamed notation имеет ряд преимушеств по сравнению с positional и mixed notation:\n\tЛучшая читаемость кода.\n\tПорядок указания параметров не важен и не может быть неправильным.\n\tВызов подпрограммы должен быть изменён только если в декларации добавлен новый обязательный формальный параметр.\n\tПозволяет избежать трудно диагностицируемых ошибок при нарушении порядка указания актуальных параметров, особенно если они литералы.\n\tи является рекомендуемым для вызова подпрограмм при написании нового или рефакторинге старого кода, и особенно тех, которые поддерживаются кем-то другим.',
                   'Для SVG нужно указывать viewBox аттрибут, если вы хотите поведение svg, как картинки. Иначе svg не будет масштабироваться. Насколько это является проблемой - вам решать. В остальном - современные браузеры поддерживают svg давно, можно не париться.\nВторая проблема - svg труднее сделать, чем png. Художники/дизайнеры как правило работают с растровой графикой: векторный svg скорее является в web полезным дополнением, нежели новым подходом.\nНапример под векторную графику был заточен Flash, но он сейчас не живой.',
                   ]
        profiles = Profile.objects.all()
        questions = Question.objects.all()

        j = 0
        while j < len(questions):
            usedAnswers = []
            i = 0
            numberAnswers = random.randint(1, 5)
            self.stdout.write('Number of Answers "%d"' % numberAnswers)
            while (i < numberAnswers):
                currentProfile = profiles[random.randint(0, len(profiles) - 1)]
                currentAnswer = Answer(profile=currentProfile)
                currentAnswer.question = questions[j]
                while (currentAnswer.question.profile == currentAnswer.profile):
                    currentAnswer.profile = profiles[random.randint(0, len(profiles) - 1)]
                tempAnswerNumber = random.randint(0, len(answers) - 1)
                while (usedAnswers.count(tempAnswerNumber) != 0):
                    tempAnswerNumber = random.randint(0, len(answers) - 1)
                usedAnswers.append(tempAnswerNumber)
                self.stdout.write("%d " % tempAnswerNumber)
                currentAnswer.content = answers[tempAnswerNumber]
                currentAnswer.save()
                i = i + 1
            j = j + 1
